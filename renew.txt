. o (    the  shok  command shell    ) o .


shok is a cross-platform non-POSIX interactive command shell.  Similar to sh
and DOS, it allows the user to invoke programs and script their execution.
shok will provide a secure, platform-agnostic, and user-friendly programming
language that is designed to facilitate filesystem interaction and system
management.

Goals:
 - secure shell environment
 - user-friendly syntax
 - clean embedded programming language
 - platform-independent semantics suitable for system administration
 - facilitate filesystem manipulation, job management, program invocation
 - Free and open-source software (GPLv3)

shok is in the very early stages of development, and not currently usable.  A
reference compiler is under heavy development, and many features are planned,
but most are unimplemented and many core features are still under discussion.
We also understand that it is dangerous to use a shell that has not withstood
rigorous testing.  If you are interested in shok, please join our mailing list
and get involved in the language and compiler development.

To help build shok, please contribute via gittip, PayPal, or bitcoin!  shok is
Free software; its growth relies on community investment by way of financing,
coding, and community involvement.

Join us on IRC: freenode #shok


The shok approach:

A command shell is a program that lets the user run other programs.  It also
provides a programming language for scripting the invocation of programs and
some interactions between them.

Most command shells have lousy scripting languages, in part because the
programming syntax needs to disguise itself around (or make itself a part of)
the shell's default action: running programs.  Alternatively, programming
languages typically provide an ability to invoke external programs, but are
cumbersome or impossible to use as an interactive shell.

shok takes a novel approach to minimize this trade-off.  It provides a natural
syntax for switching between the command shell and a fully-featured programming
language.

In haiku form:
      all there is to shok
  { write code in curly braces }
     : colon runs commands

Example:      (list results in gray!)

  # just a normal shell
  cd /media/usb_key
  ls papers/
  {   # switch to programming language
    new authors_file = 'authors.txt'    # make a variable
  }
  touch {authors_file}    # access the variable from the command-line
  echo I have {4*3} hearts: { '<3 '.repeat(12) }    # expressions as program arguments
  {
      new cutoff_date = date(2013, 4, 17)
      each f:file in ~/research/ {    # loop over files in a directory (path literal)
          if f.modification_time >= cutoff_date {
              print("copying " ~ f ~ " to usb key")
              : cp {f} papers/                      # : runs a command-line
              : grep AUTHORS {f} >> {authors_file}
          }
      }
  }   # the code won't run until we get back to the } with no syntax errors

This example demonstrates:
 - {}'s switch from the command-shell to the programming language.
 - Variables at the topmost scope of the programming language are global, and
   can be accessed from any subsequent {}'s.
 - From the shell, {}'s can pull a variable or expression from the language
   onto a command-line.
 - Retrieving a value this way is safe -- the value could never be interpreted
   as shell code!
 - Within the programming language, a : at the start of a line makes it a
   command-line.
 - Nothing is executed until the last block is closed, and there are no syntax
   errors.  It is a strongly statically-typed, compilable language.
 - Path literals and other language features complement shell programming.


Other features:
 - Familiar shell features like pipes and indirection, with some polish.
 - Security-conscious transitions between language constructs and program
   invocation
 - Object oriented programming with "static prototypes"
 - Strongly, statically-typed and compilable language: prevent errors *before*
   destructive program invocations can occur.
 - Lexically-scoped, copy-by-value memory model: No garbage collection,
   deterministic semantics.  Safe programming with controlled mutation and
   ownership, references are explicit and restricted to ensure safety.

