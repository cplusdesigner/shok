ProgramInvocation: [cmd %s%s
Endl: CmdEnd: ]

CmdBlock: [       (via CmdBlockStart)
ExpBlockProgram:   cmd {exp %s
ExpBlockEnd: }
  (ProgramMore, ProgramArgs)
Endl: CmdEnd: ]

CmdBlock: [       (via CmdBlockStart)
CmdCodeBlockBody: } wn     fires CmdCodeBlockEnd
CmdCodeBlockEnd: ]

CmdBlock: [       (via CmdBlockStart)
CmdCodeBlockBody: new x;               (via StmtEnd after SEMI CmdCodeBlockEndl)
                  new y}               (via LazyBlockEnd in CmdCodeBlockEndl,
                                        then getting finished by the StmtEnd)
How do we  ]  here?  I guess the StmtEnd will have to figure that out!  It's
popping the last guy off the stack.

We could even make that a special CmdCodeBlockStmtEnd.....

OR CONCOCT A MORE ELEGANT SCHEME ALTOGETHER!

CmdLine: wn | <ProgramInvocation:CmdEnd> | CmdBlock
ProgramInvocation: [w Program ProgramArgs Endl]       '[cmd %s%s' [1 2]
  CmdEnd: emit ']'

CmdBlock: [w <LBRACE:CmdBlockStart>         CmdBlockStart: emit '[{'
             <(ExpBlockProgram | CmdCodeBlockBody):CmdEnd>]

ExpBlockProgram: [w Exp w <RBRACE:ExpBlockEnd> ProgramMore ProgramArgs Endl]
  ExpBlockEnd: emit '(exp %s)}' parent.[1]
  ProgramMore: emit ' %s'
  ProgramArgs: emit ',%s'
  CmdEnd: emit ']'

CmdCodeBlockBody: *(n | <[RBRACE End]:CmdCodeBlockEnd> |
                        <[Stmt,CmdCodeBlockEndl]:StmtEnd>)*

End: [w SEMI] | wn
CmdCodeBlockEndl: [w SEMI] | wn | <[w,RBRACE,End]:BlockLazyEnd>


CURRENT OUTPUT:
---------------
{new x; new y}
  [{(new ID:'x');(new ID:'y');}]

a b c
  [ID:'a', ID:'b', ID:'c']

a {x} b
  [ID:'a', {(exp ID:'x')}, ID:'b']

{x}a b c{3+2}d
  [{(exp ID:'x')} ID:'a', ID:'b', ID:'c' {(exp (PLUS INT:'3' INT:'2'))} ID:'d']

