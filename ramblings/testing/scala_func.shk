abstract Window {
  draw : @()
  getDescription : @()->str
}

new simple_window = Window & {
  draw = @() { print("in simple_window") }
  getDescription = @()->str { return "woo I'm simple" }
}

abstract WindowDecoration = Window & {
  win : Window    # abstract member...
  draw = @() { win.draw() }
  getDescription = @()->str { return win.getDescription() }
} & @(w:Window) { win=w }   # insufficient to make us a real object??

# aha here we go
abstract WindowDecoration = Window & {
  win : Window    # abstract member...
  draw = @() { win.draw() }
  getDescription = @()->str { return win.getDescription() }
}
new makeWindowDecoration = @(wd:WindowDecoration, w:Window)->wd {
  wd.win = w
} #### uhhhhh syntax weirdness; other ways to write this... do we have to & in
  ###### the initial value for the abstract member?
  ######## and don't we need to have an actual concrete Window?  I guess that's
  ######## all that we could ever be provided, so that much is assumed, eh?

abstract HorizScrollDec = WindowDecoration & {
  draw = @() {
    self->WindowDecoration.draw()
  }
}

new mywin = simple_window & 

-----
digression: uhhh abstracts... how to instantiate with required constructor arg?

WHY do I want these decorations to be attached to (instantiated avec) a Window?
Why aren't they just windows on their own?  Can I multi-inheritance/forward
windows together somehow??


