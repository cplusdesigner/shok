CmdLine = Seq(
! w,
  Or(
!   NEWL
    ProgramInvocation
    CmdBlock
  )
)

ProgramInvocation = Seq(
  ProgramBasic
  Star(Seq(ws, ProgramArg: ' %s', [1]))
  FINISH emit ']'

ProgramArg = Or(
! ProgramBasic
! LBRACE w Exp w RBRACE

CmdBlock = Seq(
! LBRACE
  Or(CodeBlock, ExpBlock)
  Finish(emit RBRACE)       !!PUSH
)

ExpBlock =
  Exp
  

-----
Parser has stack.
Top of stack is "context".
CmdLine:
  WS*
  NEWL | '{' => Push(CmdBlock) | ProgramBasic => Push(ProgramInvocation)

CmdBlock: start = emit '{'
          NEWL => Push(CodeBlock)
  ....

-----
The top parser should be a fake magical parser.  It has a stack.  The
top of the stack is the "Context" parser.  When the top parser is
given a token, it passes it directly to top of stack.  If top of stack
turns done, it greedily pops...?

oK some weirdness is that we know to output a command only at....
NEWL.  But all blocks we'll know at the }.  A specific block, the
outermost CmdCodeBlock, emits a ] afterwards.

=====
An OrParser calls itself "done" even if it has 2 or more branches that
are done!  but we don't have their display text yet; they might not
even agree (as far as the framework is concerned).

How does a Parser output the "amount of display appropriate for the
provided token"?  It's got to assume eventual victory and output what
it can without being wrong.

-----
I need a mechanism for display(), that is, taking sub-parsers and
tacking them through our own filter before passing them up.

For now just pass them through.  But what is the right logic?
OrParser:  only return when I have decided my branch, sure.  On that
parse and each subsequent parse in which I do not turn bad:
 - That good branch's display is our single '%s'. Thus consider our
   output:  'left{%s}right'.  On our "completing" (determining a
single good branch) parse, output left and then the current display of
that branch.  For every subsequent parse, we output that branch's
parse.  How do we get to 'right'?  We don't -- not through parse().
At finish()-time is when we output the finish() of our parser,
followed by 'right'.

SeqParser: Suppose our display is 'one{%s}two{%s}three'.
 - Any individual item might go done, then need to be fed many tokens
   until it turns bad until we know to advance and fire a slew of
buffered tokens to its subsequent item.
 - So too we must be careful with our displays.
 - We can't display an item until we have advanced to the next one!
 - The last item won't be ready until finish().
  -- wrong, when we're on the last item we can display anything it
wants.  Of course there may be "past the last %s" text that must wait
for finish() just like any other parser.

No.  New scheme:
Smthg = Seq('foo', [(One,'a%sb'), (Two,'c%sd'), Three, (Four,'e%sf')])

self.displays[] tracks just the tokens that come out of the active
parser -- ie the %s part.  Have a firstparse bool, at that parse we
emit just msg_start[0].  At any advance, emit displays[pos-1] +
msg_end[pos-1] + msg_start[pos].

Nono.  Don't be so greedy.  WHEN we advance, we output
msg_start[pos-1] + displays[pos-1] + msg_end[pos-1].  We have a
firstparse bool for the LAST stage, which means emit msg_start if it
emits at all.  Otherwise, msg_start will be catched in finish().

PlusParser:
 - Easy.
 - If we move bad, return ''
 - If we move done, irrelevant.
 - On each parse, we feed the token to our active parser.
 - If it turns bad, and we weren't done, return '', and we're irrelevant anyway.
 - If it turns bad, but we were done, don't use that return value (it should be '' anyway).  We restart, and that's fine.
 - Normal case: just return the display of the active parser.

StarParser: just like PlusParser.  Though I guess we can output "left"
immediately (which really means "after the first token"), but that's a
bit silly
