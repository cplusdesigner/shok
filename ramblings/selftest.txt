Suppose object-literal {}'s define self, and within @{} we can refer to self
but nothing outside of ourselves.

{ new A = {
    x = 1
    y = { x=2 } & @() { print x ~~ self.x }
 }
  A.y()   # 2 1
}

{ new A = {
    x = 1
    y = @() { print x }   # error: x is undefined.  boo!
  }
}

new x = { op() = @()->self {} }
new x = { op() = @()->s:self {return s} }   # returns an x or child of x
new x = @()->self {}      # maybe undefined, depends if we're in an object
new x = @()->s:self {return s}        # again, self might be undefined here

Let's relax a bit.  New spec:
Object-literal {}'s define self, and within @{} we can refer to self *and*
stuff from our enclosing object-literal.

{ new A = {
    x = 1
    y = {x=2} & @() { print x ~~ self.x }   # the self is required to get A.x
  }
  A.y()   # 2 1
}

{ new A = {
    x = 1
    y = @() { print x }   # 1 -- ok!
  }
}

Note that within (new A = {...}), 'A' and 'self' have different meanings, as
described by the "BIG difference" in constructors.txt.  But with nesting of
functions and objects, 'self' can become locally-replaced thus we loose the
ability to refer to an outer self.  In those situations we'll just have to have
aliased the outer object.  Alternatively, we might have a self.parent :-)


if x == horse, x.neigh()
if y is a horse, y.neigh()
