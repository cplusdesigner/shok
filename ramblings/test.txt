Lush.parse('{')

Have no stack, so we go (Lush's local)CmdLine.parse('{')
CmdLine.wn goes bad
CmdLine.ProgramInvocation goes bad
CmdLine.CmdBlock goes ok
CmdLine OrParser has a single done branch.  Gets CmdBlock's partial display
text ('[{') and emits it to ast.
CmdLine asks its done branch if it has a topmost
CmdLine is pushed on stack.

Lush.parse('if')
CmdLine on stack: CmdLine.parse('if')
CmdLine.CmdBlock.parse('if')
CmdLine.CmdBlock.ExpBlockProgram goes bad, so only CmdCodeBlock is ok here (but
we don't know that yet).  In CmdCodeBlock, only BlockOrCmdStmt is ok.  In
BlockOrCmdStmt, only Stmt is ok.  In Stmt, only StmtIf is ok.
CmdLine.CmdBlock has a single done branch.  Requsts the partial display of its single done parser.  That display() crawl will need to find the topmost Or within that.  This sounds recursive....

SUPPOSE we are doing the FIRST getDisplaySoFar(), that is, some branch of some
OrParser JUST concluded it knows which branch.

OrParser.getDisplaySoFar():
 - if I don't know which branch yet: error, I think.  Noone should have asked.
 - if I have a single done branch: awesome.  Push me on the stack.  return
   branch.getDisplaySoFar().
BUT we only want to push on stack if this is the FIRST of the
getDisplaySoFar()s.  Hmmmmm.

SeqParser.getDisplaySoFar():
 - I know my position.  Accumulate and return the display()s of all the parsers
   up to that point.  Mark them each as having no display left, or maybe just
   remove their entries in disps or smthg.

PlusParser: Emit all my disps and purge it.

-----

LushParser() returns Lush()
Lush: The root of our parser tree, but not a Parser.Parser.  Implements its own
parse(token):
 - has a stack [], ast '', and parser = MakeParser(CmdLine, self)
 - if stack has items: stack[-1].parse(token)
 - else, parser.parse(token)
 - if whatever parsed goes bad, restart()
 - return value of the parse() gives us back a ParseResult.  We append its .ast
   to our ast.

PlusParser.parse(token):
 - parser.parse(token)
 - if we went bad but we were done: try to parse again from the start
 - if we go bad or done: that's cool, but not actionable.
Need:
 - we should be able to get the partial display
   - both cumulative and per-token

StarParser.parse(token):  just like PlusParser but it also starts done

SeqParser.parse(token):
 - track the active position
 - done anytime that the last rule is done
 - while feeding tokens to any not-the-last rule: we buffer the tokens, so if
   it goes bad, we can flush the tokens across the rules that came after
Need:
 - we should be able to get the partial display

OrParser.parse(token):
 - feed the token to each parser:
   - if it moves done, put it in a doneparsers list
   - if it moves bad, remove it
 - if we are left with 1 done parser:
   - if it's done, we are done

Let's try and keep the get-display (cumulative, per-token, done) as a
post-processing thing sent down by the stack-top / root-level parser...

Now: who notices when we might need to push/pop stack etc.:
 - the root parser could ask, since it IS special.
 - crawling down the tree, we should be able to determine for ourselves a lot
   of the stack.  Wait, all of it?  Hmmmm...
 - that's the point, we used to not really need a stack.

Top of stack: a shortcut to get where we knew we were.
After it processes through, IT might know it is either now done, or bad.  It
also knows what the last token to float through was.
 - It can say: I can choose a branch now:  float through "pick the next
   winner".  Does EVERY item along the way put itself on the stack?  That seems
   nice, then any of the things can have an atPop. uhh, do we want that? idk.
 - It can say: whoaaaaa I've turned bad, or just done (maybe not fully done).
   Or actionable-done, say, on NEWL.  hmm what do we want..

I don't want parser-tips to have go backtrack backwards, because... they might
not know if they're fully done!  There are specific scenarios in which that is
known to something at its end.  e.g. ENDL.  And those will want to pop
backwards some distance.

Fan out.
cull back.  (parse returns a struct)
Fan out again.
cull back again.

Make a model where those are easy, and then figure out where my domain-specific rules can be?

More abstractly: I have a feeding mechanism.  And I happen to be building a
parser out of it.

----
Going back a step or two.
Every parse() can return whatever amount of display it gets out of that
individual parse, an amount that is TOTALLY CONFIRMED.  Which might not be
much, or might be late.  That's fine.
Some parsers will accumulate the parses (displays) it gets out of sub-parsers
until it's ready to emit.

Fan out 1: Parse as much as you can gogogo!
Cull back 1: (parse's return value) Pull back errors.  Accumulate what displays
it can confirm.

This is PHASE 1.  We'll determine what requirements we have for second-fan,
topmost-unfinished-Or-parser, Actions, etc. as we do that.

fan 1: "parse"
fan 2: "cleanup"

Fan out 2: Find the top-most unfinished Or-parser.



-----
ooooo

is inheritance actually good?  datetime.date  vs.  datetime&=date... hrrrm.

