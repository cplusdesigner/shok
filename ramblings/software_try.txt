abstract int = {
  my value : os.int   # only editable by this instance, but viewable to all
  op+ = @(rhs:self)->self { value += rhs.value }    # implications of 'self'???
    # os.int implements op+ and therefore += is defined for it
    # returns ->self so automatically performed in a new, writable context
    # which is then returned implicitly
  new = @(i:int_literal)->self { value.assign_literal(i) }
}


What happens if int.op+ :: @(rhs:int)->int ??

What happens if int.op+ :: @(rhs:int)->r:int?r>self   !?!?

Need to think about these in the context of non-int.  Let's go back to animal.

abstract Exterior : {| skin | feathers | scales |}

abstract Animal = {
  name:str
  age:int
  ext:Exterior

  new = @(n:name, a:age, e:Exterior) {
  }
}

new can only be defined and called on an abstract.  Its return type is
implicit.  We don't say ->self because it's not returning "self" (which means
the implementor, which does not have a new), it's returning a new (name of the
abstract).
That's wrong -- an abstract could descend from another.  OK I have no idea what
inheritance is anymore.

new date = {
  year:int
  month:int?($>=1 and $<=12)
  day:int?($>=1 and $<=31)
  op+ = @(rhs:date)->r:date {     # no selfs for now
    r.year = year + rhs.year      # wrong lol but go with it
    r.month = month + rhs.month
    r.day = day + rhs.day
  }
} & @(y:int, m:int, d:int)->self {    # use of 'self' here?
  year=y; month=m; day=d              # implicitly we're in the new one
}
# warning: date is abstract (because type restrictions make the default
# unusable).  That's excellent, this date IS abstract.  We could either keep it
# abstract and give it a magically-disappearing new, or we could relax the
# restrictions.  Let's pretend the restrictions are gone so that the 0/0/0
# default date is fine.

new d1 = date
new d2 = date(2013,1,29)

new d3 = d1 + d2
d1 += d2      # always fine if `+` returns its self.  Because we're
              # replacing our object; noone's modifying its members.

Every date is a function that creates and returns a new date.  That's kind of
silly.  It really should have been abstract......
d3(2012,1,16)     # a no-op! ..... always!!??? NO, there could be side-effects,
                  # like I/O, just we know that *d3* has not been modified.  lol

new datetime = date & {
  hour:int, min:int, sec:int
}

# ^^ continue testing inheritance!
