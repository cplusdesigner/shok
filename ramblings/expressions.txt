{
  new pokemon = {
    name:str
    type:str
    level:int
  }
  new pikachu = pokemon & {
    name='pikachu'
    type='lightning'
  }
  {
    new trainer = {
      poke=pikachu
    }
  }

  new a
  new foo = {
    digi:str
    mon:digi
    age:int
  }
  {
    new x = 17
    new roar = @()->foo {
      new age = x
      return { digi='DIGI'; mon='MON', self.age=age }
    }
    x = 12
    return roar()
  }
}

{
  new x = int & { pika = pokemon }
  foo(x)

{
  new x = { foo:date=$today; bar:str } & @(){ foo.year += 4 }
}

How did the function know that foo was a valid symbol?  It can't.
That's kind of sad.  We could:
 - require that 'self' is used to refer to members, and then any `self.` would
   skip some analysis and be assumed to make sense anywhere (!)
 - simply not do that level of analysis in a function def.  That means we have
   to be careful about what setup() is allowed to do anywhere, actually it
   becomes extremely limited and can't do any type-checking on a function
   until...  when?  When we do setup() on the expression that contains it?

Oh, simple.  The parser already enforced syntax constraints on the function,
that's pretty reasonable until such time as we validate the whole expression in
which the function takes place.  We need to wait until then to do the rest of
our static analysis (typechecking etc.) so, well, so be it.

The only real alternative is to make function-objects have their objects be
specified first before the functions are &'d in.  I certainly don't care to
implement that restriction now even if we decide it's desirable.

^ welp I take that back lol

