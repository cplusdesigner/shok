# forget about syntax for now.  what are named blocks, functions, objects, and
# types?

new max = @(int a, int b)->int {
  if (a > b) { return a }
  return b
}
max &= @(float a, float b)->float {
  if (a > b) { return a }
  return b
}

new max |= 

max is clearly a variable holding a specific function that takes two ints and
returns int.  The function only exists in variable scope.

new date = var {
  self += @(int


what about
new @max(int a, int b)->int {
}

^^ that way I can have different max's with different signatures in the same scope.

new x = positive-num @{
}

^^ not sure what to do with this...


-----

:{
  # anonymous execute-now block statement (cannot be assigned)
  # cannot take any arguments
  # returns its last expression as ->str.escape()
}

{
  # anonymous execute-now block statement (cannot be assigned)
  # cannot take any arguments
  # no return value
}

new x = @{
  # named execute-later block
  # the @{} returns itself; it is an expression
  # could have had arguments; this one doesn't
  # You can run the block by calling it:  x()
}
# equivalent:   new x = @ {}
# equivalent:   new x = @() {}
# equivalent:   new x = @()->void {}
# equivalent:   new x = @->void {}
# invoke as:    x()
#
# ...nurrr...... I hate multiple equivalent ways to write the same thing!!!

new x = @(str)->int {
}

new print = {}      # illegal!
                    # OR is this a better way to do labels !!??
                    # (Or would that be waayy too confusing?!)

new print = @{}         # print is a void->void function

new print = @(str) {}   # print is a str->void function

new print = @(str)->int {}    # print is a str->int function

new print = positive-int {
}

# A function that returns void
new print = @(str) {
  os.print(str)
}

# a function that takes no args and returns an int
