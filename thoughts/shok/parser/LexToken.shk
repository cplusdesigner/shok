#!/bin/shok

{
  new LexToken = {
    colno : int
    ttype : str
    tvalue : str
    new = @(tokenstr:str)->self {     # replaces default new.... hrrm..
      new t = tokenstr.split(':')
      if t.size() < 2 or t.size() > 3, throw "invalid token:" ~~ t
      colno = t[0]
      ttype = t[1]
      if t.size() == 3, tvalue = t[2]
    }

    op->str = @()->str {
      if self.tvalue == '', return '<{0}:{1}>'.format(colno, ttype)
      return '<{0}:{1}:{2}>'.format(colno, ttype, tvalue)
    }
  }

  new NewlineToken = LexToken.new('0:NEWL')
}

(*
  The 'new' (instead of op()) discourages users from using LexTokens like a
  function that erases/replaces a bunch of the token's state.

  Don't forget: copy by value!  so "new" is just a helper, but other "copies"
  are safe too..  It seems weird to be able to call  45.new(23)  or even  45(23)

  So we don't.  Int is an int factory?
  abstract int = {
    value : os.int      # os.int is abstract maybe, thus making int abstract too
  }
  new Int = @(il:int_literal)->int {
    return int & { value = il }
  }

  But then I don't know if I should make an int or look for an Int to use to
  make it.  Seems nicer to use "new" to bring the factory along with the
  object, and then children can replace that instead of also having to make
  their own factories that somehow descend from that factory tree.

*)


