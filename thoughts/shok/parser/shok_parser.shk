#!/bin/shok

{
import logger
new log = logger.new()

import os
import sys
import LexToken
import ShokParser

defer main
main(os.args)
exit()

new Restart = @()->Parser {
  return ShokParser.new()
}

new parse = @() {
  new parser = Restart()
  loop {
    new line:str
    try {
      line = sys.stdin.readline()
    } catch e:exception.KeyboardInterrupt {
      log.info("Keyboard interrupt; done")
      return
    } catch e {
      log.error("Error reading from stdin:" ~~ e)
      return
    }
    if line == '' {
      log.info("End of input; done")
      return
    }

    try {
      new ast = ''
      line = line.strip()
      log.info("!" ~~ line)

      if line != '' {
        new tokens = line.split(' ')
        new lineno = tokens[0]->int
        tokens = tokens[1..end]
        each token in tokens {
          new t = LexToken.new(token)
          log.info("! sending token '"~t~"'")
          ast += parser.parse(t)
        }
      }

      if parser.evil, throw parser.err("Top parser went evil")
      elif parser.bad, throw parser.err("Top parser went bad")
      log.info("! sending token '"~NewlineToken~"'")
      ast += parser.parse(NewlineToken)
      try {
        print(ast)
        sys.stdout.flush()
      } catch e {
        log.error("Error writing output:" ~~ e)
        print "Error writing output:" ~~ e
        sys.stdout.flush()
        return
      }
    } catch e {
      log.error("Parse error:" ~~ e)
      print("::Parse error:" ~~ e)
      sys.stdout.flush()
      parser = Restart()
    }
  }
}

new main = @(args:[str]) {
  if len(args) == 2 {
    new lev = args[1].upper()
    log.setLevel(lev)
    parse()
  } elif args.size() != 1 and args.size() != 2 {
    print("usage: {0} [log level]".format(args[0]))
  } else {
    parse()
  }
}

}
