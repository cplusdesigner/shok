What's our special rule for references?
Use the type system to note the lifetime of any object, and require reference
lifetime <= object lifetime.

e.g. an object foo must outlive a reference foo*.

What about other rules?
 - Lifetime of a parent object vs. its child object
    - for children that add nothing (copies)
    - for children that add/restrict stuff and are assigned
    - for children that add/restrict stuff and are returned
 - Lifetime of an @foo() designator
 - Lifetimes and modules


new animal = {
  name:str
}

new x

new test = @()->object {
  new lion = animal & { roar = @() { print "roar!" } }
  lion.name = 'simba'
  return lion
}

x = test()

typeof x        # x :: animal

if x is a lion, print("lion!")      # unknown type "lion"... that kinda sucks?

This might be a consequence of not having reconciled "class-like parent" vs.
"interface (polymorphic) parent separate from implementation re-use" thinking.
Specifically, when we define internal-forwarding delegation semantics, the
scoping may fall apart.

new test = @()->object {
  new lion : animal = {
    readonly _animal:animal
    name => _animal
  }
}

Suppose lion :: animal :: object as follows:
{
  new animal = {
    name:str
    say = @() { print "animal" }
  }

  {
    new lion = animal & { roar = @() { print "ROAR!" } }
    new animalMaker = @(s:str)->animal {
      if s == 'lion', return lion
      return animal
    }
  }
  # a-ha!  I can't possibly call animalMaker() here.
}

So when could a lion ever be returned outside its scope?  Only the following:
{
  new animal = ...
  new animalMaker = @()->animal {
    new lion = animal & { roar = @() { print "ROAR!" } }
    return lion
  }

  new simba = animalMaker()
  typeof simba      # simba :: ???     must be animal!
}

Well that's no problem at all.  If an object needs to be part of the public
interface, i.e. consumers may need to know the name of some specific type it
is, then it had better be in their scope.  BUT ... hrrrm.  What exactly is the
object simba??  We have some options for what happens when a subtype is
returned out of its scope:
1. auto-cast down to the base type that is still in scope.  Strong assertion
that objects can always do that and that it's always safe / reasonable...... boo
2. keep the object whole, it just has some members that MIGHT be relevant to
its operation, but that are no longer publicly accessible.  A bit strange
maybe?  But if you wanted the right type, it should have stayed in scope...  ew
but then objects can appear magical.  WELL, not REALLY magical.  That object is
now the last representative of his type.  If you want another, you just copy
him!  This is metaprogramming, e.g. "give me a base type like this!" haha.
Groovy.  It's just like how:
  new datetime = date & { hour:int; min:int; sec:int }
  datetime :: date
but datetime subtypes date; has more members, and type restrictions maybe!


