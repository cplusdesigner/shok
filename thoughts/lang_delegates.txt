The most problematic datatypes for equality are the function objects--simple functions ("compiled-functions") and function closures ("FUNARGS" [Moses70]). We would like to compare closures properly because they can be used for object-oriented programming based on delegation instead of inheritance [Snyder86] [Lieberman86] [Ungar87]. Simple functions access only their arguments and global variables, and therefore require no environment pointer; e.g., the C language [ANSI-C] provides simple function objects, but not function closures. Simple function objects in a functional language which do not reference global names are called combinators. Function closures are data structures incorporating both a simple function and an "environment" mechanism which provides the values of the "free variables" in the simple function; e.g., Algol-68, Pascal and Lisp offer lexical closures; Ada can approximate function closures using tasks [Lamb83].

 -- from http://home.pipeline.com/~hbaker1/ObjectIdentity.html (Baker)

Let's check out: We would like to compare closures properly because they can be used for object-oriented programming based on delegation instead of inheritance [Snyder86] [Lieberman86] [Ungar87].

Snyder86: Boring, lisp-y, talked about "object identity" in the
context of trying to define wonky equality operator.

Lieberman86: YES he invents prototypes!!
http://web.media.mit.edu/~lieber/Lieberary/OOP/Delegation/Delegation.html
And motivates them being cool  :)

and gems such as: "Obviously, an object representing a method cannot
itself have methods, otherwise infinite recursion would result."
