Inheritance
-----------

object = { varname:str }
new A = { a = 1 }   # & implicit { varname = 'A' }
new B = { b = 2 }   # & implicit { varname = 'B' }
new C = A & B       # & implicit { varname = 'C' }

C :: A & B
C.a == 1
C.b == 2
C.varname == 'C'
C->A == A   # access internal "forward"
C->B == B
C->object   # This gives us the object of just the object-members of C

Need to make sure that these -> casts make sense.  That even though we
don't allow self-modification in methods, we're not breaking something
(particularly by not allowing A to pick up changes to stuff in C where
C overrode those parts of A).  Test against both our public and
'internal' (ok what are we calling them now?) members.

Even though C's methods don't modify C, they DO modify a clone of C
that gets returned.  Inside that clone, what responsibilites do I have
to maintain members of my A and B??

Then try out conflict scenarios, for vars and for functions.

Then try out SUBTYPING MEMBERS.

# Test conflicts that have overlapping types; say overlapping method
# signatures.  Now what happens in C->B ?

Finally, we might want the ability to rename what C calls its ->X when
it inherits an X.


