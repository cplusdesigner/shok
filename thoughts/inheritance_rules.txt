object = { varname:str }
new A = {
  a:num=1
  my _a:int   # only methods that return a new 'self' can change this
  op() =  @(x:X,y:_a)->z:a { return a }   # this cannot modify any of A's vars
  op() &= @(n:num)->self { a=n; _a=2 }
}
new B
new C = A & B & { renew a:int, _a:5 }
# ERROR: C() (inherited from A) assigns to C.a (an int) with less restrictive
# type 'num'.  Please override C().

That's because C looks like this:

C <=> {
  a : num = 1
  my _a : int
  A : self.outer.A    # public?  Ya sure, why not...  no priv inh for now ;)
  B : self.outer.B    # 'outer' is maybe a hack...
  op() = @(x:X,y:_a)->z:a { return self.A(x,y) } &     # not a "mutator"; safe
         @(n:num)->self { new __tmp_A = A(n); a = __tmp_A.a; _a = __tmp_A._a }
}

We also know that
typeof C.op() :: ... & @(n:num)->self with(self.a:num, self._a:int)

right?  or something like that?  need to make explicit the contravariant
assumptions.

Also I don't see any reason why any method shouldn't be capable of modifying
self, given we're accounting for all the rules anyway......... maybe just to
make things nice?  srsly?
