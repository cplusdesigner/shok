Objects may have a special member op(), which if present must derive from @.
If an object has one

new animal = {
  name:str
  @(name:str, age:num)->str {
    self.name = name
    self.age = age
    return "lolz"
  }
  age:num
}

nonono.
-----
new max = @(int a, int b)->int {
  if a > b, return a
  return b
}
max :: @(int,int)->int :: @->int :: @

If you really want anything that takes @(int,int) whether or not it returns an object or nothing at all (void), you should use | and then pick exactly which of those two you care about in your body.  For now.  I can't think of a reason to only care what something takes and not what it returns.
 - is that true?  what about  bind()  ??  humph.

nonono.
-----

An object is just a set of members.  A function is a special thing.  Any object
can also be a function just by &'ing it in.  An internal op() member doesn't
exist, that's not quite how it's modeled.  Different function signatures
provide different types of special-internal-function-members.

Object hierarchy:

    object            @
    |        |--------|-------------|
    animal   @(str)   @(int,int)    @->int
    |        |
    |        roar
    |  |-----|
    lion

new animal = { name:str; age:int }
animal :: object

new roar = @(name:str) {
  print name ~~ "roars!"
}
roar :: @(str) :: @

new lion = animal&roar
lion :: animal&roar :: object&@(str) :: object&@

new max = @(int a, int b)->int {
  if a > b, return a
  return b
}
max :: @(int,int)->int :: @(int,int) & @->int :: @

A function is just a procedure AND it has a return type.  A procedure (returns
void) is a strict subset of a function (that has a return type)!!  You can use
a function anywhere you would have used a procedure!


Multiple Inheritance:
If a and b both have a .x member, then you cannot define c = a&b.  It's a
syntax error, even if a.x and b.x share the same type.  This guards us against
*semantic* collisions.

But if Y = { x:object } and a=Y and b=Y,  then  c = a&b  is fine.  I *think*
all of the multi-inheritance I want to do is of this form.

This is also what blocks inappropriate method clashes.
When you make a function, you're actually making an object that has a single
builtin magical member that does nothing more than encode the function
signature.

new max = @(a:int,b:int)->int {
  if a > b, return a; return b
}
is syntactic sugar for:
new max = @(int,int)->int & {
  __builtin__function__int_int_returns_int__ = {
    a:int = __builtin__function__bind_arg__(1,int)
    b:int = __builtin__function__bind_arg__(2,int)
    __builtin__function__body__ = __builtin__code_block__(QUOTE{
      if a > b, return a; return b
    }QUOTE)
  }
}

with:
abstract @(int,int)->int = @(int,int) & @->int & {
  __builtin__function__int_int_returns_int__ : __builtin__
  __builtin__function__int_int__ = __builtin__function__int_int_returns_int__
  __builtin__function__returns_int__ = __builtin__function__int_int_returns_int__
}
abstract @(int,int) = @ & {
  __builtin__function_int_int__ : __builtin__
  __builtin__function__ = __builtin__function__int_int__
}
abstract @->int = @ & {
  __builtin__function__returns_int__ : __builtin__
}
abstract @ = {
  __builtin__function__ : __builtin__code_block__
}

uhoh, have we lost the ability to overload with different args and/or return
types?  No!  We're still ok!  Let's try it out:

new max = @(int a, int b)->int {
  if a > b, return a; return b
} & @(float a, float b)->float {
  if a > b, return a; return b
}

max :: @(int,int)->int & @(float,float)->float
    :: @(int,int) & @->int & @(float,float) & @->float
    :: @

max fulfills the contract of each of its abstract parents.  And a caller knows
it can't call max(int,float) or expect max(int,int) to return a float.  Even if
it asks istype max @(int,int)  (true)  and  istype max @->int  (true)  it can't
statically expect @(1,2) to return a float in any way; there's no way.
@(int,int) doesn't necessarily say it returns anything, so it can't be used to
get any return type, let alone one we might have expected to be a float.  We
have to be going through the full func spec types like @(int,int)->int.
@->float just means "I *can* return a float", which fits with everything else.
Holy moly I think this works!
