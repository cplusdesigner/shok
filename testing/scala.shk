abstract Window {
  draw : @()
  getDescription : @()->str
} & new = @(draw, getDescription)->self

new foo = Window        # nope
abstract foo = Window   # ok
new foo = Window(@() {}, @()->str { return 'foo' })   # ok!
foo()   # NOPE!  Window does not have a ()
foo.new()   # NOPE!!  foo :: Window, but foo does not have a new()
            # Can only abstracts get a new, then ??

new foo = Window!(@(){}, @()->str{return 'foo'})

new simple_window = Window & {
  draw = @() { print("in simple_window") }
  getDescription = @()->str { return "woo I'm simple" }
}

abstract WindowDecoration = Window & {
  win : Window    # abstract member...
  draw = @() { win.draw() }
  getDescription = @()->str { return win.getDescription() }
} & @(w:Window) { win=w }   # insufficient to make us a real object??

# aha here we go
abstract WindowDecoration = Window & {
  win : Window    # abstract member...
  draw = @() { win.draw() }
  getDescription = @()->str { return win.getDescription() }
}
new makeWindowDecoration = @(wd:WindowDecoration, w:Window)->wd {
  wd.win = w
} #### uhhhhh syntax weirdness; other ways to write this... do we have to & in
  ###### the initial value for the abstract member?
  ######## and don't we need to have an actual concrete Window?  I guess that's
  ######## all that we could ever be provided, so that much is assumed, eh?

BOOM:
abstract WindowDecoration = Window & {
} & @

abstract HorizScrollDec = WindowDecoration & {
  draw = @() {
    self->WindowDecoration.draw()
  }
}

new mywin = simple_window & 

-----
digression: uhhh abstracts... how to instantiate with required constructor arg?

WHY do I want these decorations to be attached to (instantiated avec) a Window?
Why aren't they just windows on their own?  Can I multi-inheritance/forward
windows together somehow??


